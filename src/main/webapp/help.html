<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Log File Parser Help</title>
</head>
<body>
    <h3>НАЗНАЧЕНИЕ</h3>
    <p><i>LogFileParser</i> предназначен для парса лог-файлов, создаваемых в формате log4j: ConversionPattern=%d %5p [%t] %c - %m%n.</p>
    <p>В результате создаёт файл в формате .xlsx.</p>
    <h3>ИНТЕРФЕЙС</h3>
    <p>Файл выбирается кнопкой <i>Select File</i>. При этом выбирается только имя файла. Путь к файлу указывается в отдельном инпуте.</p>

    <h4>Чекбоксы:</h4>
    <ul>
      <li><i>Unique Rows</i> - в .xlsx-файле остаются только рэкорды с уникальными приоритетами сообщений (Priority), текстом сообщений (Message) и Stack Trace. Дата (Date), время (Time), поток (Thread), категория (Category) при этом игнорируются. Из группы дубликатов строк остаётся первая.</li>
      <li><i>Gather Similar Messages</i> - если текст сообщений рэкордов отличается незначительно (75% токенов в тексте совпадают), текста сообщений сливаются вместе. Вместо различий ставятся переменные. А значения помещаются в колонку MessageValues. Эта опция доступна при выборе Unique Rows.</li>
      <li><i>Errors Only</i> - в файл выводятся только рэкорды с приоритетами = ERROR. Рэкорды с приоритетами INFO, DEBUG - игнорируются.</li>
      <li><i>TrackEnsure StackTrace Only</i> - в стектрейс не добавляются строки начинающиеся с "org.", "com.zaxxer.hikari.pool", "com.sun.", "sun.security.".</li>
    </ul>
    <p>Возможен вывод ни всего файла, а только его части. Для этого нужно задать диапазон строк, который нужно обработать. При этом, если диапазон строк начинается с середины стектрейса, относящегося к рэкорду, не входящему в диапазон, то этот стектрейс игнорируется. Если диапазон строк заканчивается на середине стектрейса, то стектрейс берётся полностью.</p>

    <h3>СОЗДАВАЕМЫЙ .XLSX-ФАЙЛ</h3>
    <p>В файле создаются следующие колонки:</p>
    <ul>
        <li><i>Row</i> - номер строки в исходном лог-файле;</li>
        <li><i>Log Name</i> - название лога в составном файле. Если в файле только 1 лог, то - имя файла;</li>
        <li><i>Date</i> - дата рэкорда;</li>
        <li><i>Time</i> - время рэкорда;</li>
        <li><i>Priority</i> - уровень приоритета сообщения рэкорда;</li>
        <li><i>Thread</i> - поток, который обрабатывал логируемый класс;</li>
        <li><i>Category</i> - логируемая категория или класс;</li>
        <li><i>Message</i> - сам текст сообщения;</li>
        <li><i>MessageValues</i> - значения переменных, использеумых в колонке Message (при включённом чекбоксе Gather Similar Messages);</li>
        <li><i>Stack Trace</i> - стектрейс ошибки (если есть у данного рекорда);</li>
        <li><i>Similar Rows Quantity</i> - количество слитых вместе строк (дубликатов - строк, отличающихся временем, и строк с похожими сообщениями);</li>
        <li><i>Not parsed row</i> - строки, которые парсер не смог распарсить. Например текст, добавленный в файл вручную.</li>
    </ul>
    <p>При привышении максимального количества строк на листе (1_000_000) в книге создаются дополнительные листы. При привышении максимального количества символов в ячейке (32_767) обрезает текст в ячейке и меняет цвет шрифта с чёрного на красный.<p>

    <h3>ФРОНТ ЕНД</h3>
    <p>Фронт енд сделан с использованием AngularJS. Контроллер (<i>logFileParser.controller.js</i>) управляет динамикой html-страницы (index.html). Сервис (<i>logFileParser.service.js</i>) - отсылает запрос на бек, принимает ответ. Стили хранятся в <i>styles.css</i>. Также использован inline-метод задания стилей.</p>

    <h3>БЕК ЕНД</h3>
    <p>Фреймворки подключены при помощи Maven (pom.xml).</p>
    <h4>Сервлет (<i>LogFileParserServlet.java</i>)</h4>
    <p>Сервлет принимает запросы с фронта и отсылает ответы. В приложении только 1 енд поинт - actionName=parseLogFile. Сервлет настроен в дескрипторе развёртывания (<i>web.xml</i>).</p>
    <h4>Делегат (<i>LogFileParserDelegate.java</i>)</h4>
    <p>Делегат:</p>
    <ul>
        <li>получает из сервлета HttpServletRequest и HttpServletResponse;</li>
        <li>вытаскивает из запроса параметры;</li>
        <li>формирует имя .xlsx-файла;</li>
        <li>создаёт объект парсера (LogFileParser);</li>
        <li>создаёт объект генератора .xlsx-файла;</li>
        <li>передаёт параметры.</li>
    </ul>
    <h4>Парсер (<i>LogFileParser.java</i>)</h4>
    <p>В конструкторе:</p>
    <ul>
        <li>инициализируются поля класса переданными с фронта параметрами;</li>
        <li>создаётся поток чтения из файла. Если файл не найден, на фронт (при помощи сервлета) отсылается ошибка.</li>
    </ul>
    <p>Делегат вызывает метод parseLogFile(), который читает лог-файл построчно и преобразует в список рэкордов. Если задан диапазон обрабатываемых строк, строки до начала диапазона пропускаются. Каждая считанная строка сравнивается с шаблонами. Шаблоны могут быть следующими:</p>
    <ul>
        <li>строка содержит "** /" - если лог-файл содержит несколько логов, каждый лог начинается со строки, содержащей звёздочки и название лога. Из этой строки берётся название лога (колонка <i>Log Name</i>).</li>
        <li>строка содержит "## /" - если лог-файл содержит несколько логов, каждый лог заканчивается строкой, содержащей решётки и название лога. Такая строка означает, что больше нет строк, относящихся к текущему рэкорду. - Все временные переменные, в которых аккумулировались данные, записываются в соответствующие поля текущего рэкорда, и он добавляется в список рэкордов (метод <i>recordAdd()</i>). Аккумулирующие переменные обнуляются.</li>
        <li>"^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2},\\d{3} " - строка начинается с даты и времени. Это означает начало следующего рэкорда. - Больше нет строк, относящихся к текущему рэкорду. - Все временные переменные, в которых  аккумулировались данные, записываются в соответствующие поля текущего рэкорда, и он добавляется в список рэкордов (метод <i>recordAdd()</i>). Аккумулирующие переменные обнуляются. Создаётся новый рэкорд. Сразу заполняется номер строки (<i>Row</i>). Рэкорд наполняется данными из текущей строки (метод <i>fillMainFields()</i>). Из строки берутся <i>Date</i>, <i>Time</i>, <i>Thread</i>, <i>Category</i>, <i>Message</i>. Все последующие строки, если они не подпадают ни под 1 из шаблонов, считаются продолжением <i>Message</i>.</li>
        <li>строка начинается с "at " - строка стектрейса. - Аккумулируется в переменной, пока итератор ни достигнет строки, означающей начало нового рэкорда. В этом случае аккумулирующая переменная запишется в текущий рэкорд, а рэкорд - в список.</li>
        <li>пустые строки пропускаются</li>
        <li>строки, которые не подпадают ни под 1 из шаблонов и при этом предыдущая строка не была месседжем или стектрейсом, попадают в колонку <i>Not parsed row</i></li>
    </ul>
    <p>Если задан диапазон обрабатываемых строк, и достигнута последняя строка, которую надо распарсить, устанавливается флаг <i>needInterrupt</i>. Если при этом не достигнут конец текущего рэкорда, строки продолжают считываться из файла и обрабатываться, пока итератор ни достигнет строки, означающей начало нового рэкорда.</p>
    <p>Перед добавлением нового рэкорда в список проверяется поле <i>isErrorsOnly</i>. Если пользователь выбрал эту опцию, то рэкорд добавляется только в том случае, если уровень приоритета сообщения рэкорда = ERROR. Вызывается метод <i>recordAdd()</i>, записывающий аккумулирующие переменные (<i>Message</i>, <i>stackTrace</i>, <i>error</i>) в соответствующие поля рэкорда. Также в этом методе в мапу <i>similarRowsQuantityMapByHash</i> добавляется хеш рэкорда (в качестве ключа) и количество рэкордов с таким хешем (в качестве значения). Если выбрана опция <i>Unique Rows</i>, то рэкорды добавляются в HashSet. Хеш у рэкордов переопределён и зависит от <i>Priority</i>, <i>Message</i>, <i>Stack Trace</i>. Дубликаты, отличающиеся только номером строки, датой, временем, потоком, категорией, в сет не попадают. Но количество дубликатов записывается в <i>similarRowsQuantityMapByHash</i>. После окончания первого прохода (после создания всех рэкордов) количество дубликатов рэкорда по хешу подтягивается в поле <i>similarRowsQuantity</i> рэкорда. Если опция <i>Unique Rows</i> не выбрана, то рэкорды добавляются в ArrayList. На HashSet/ArrayList ссылается переменная <i>logRecordCollection</i> типа Collection. После окончания первого прохода из коллекции создаётся ArrayList <i>uniqLogRecordListAssembled</i>.</p>
    <p>Если выбрана опция <i>Gather Similar Messages</i>, запускается второй проход по рэкордам - вызывается метод <i>joinRecordWithMessageDuplicates()</i>. Метод сливает вместе рэкорды, имеющие одинаковые <i>Priority</i>,  <i>Category</i>,  <i>Stack Trace</i>; и <i>Message</i>, совпадающие на 75%. Вначале все рэкорды разбиваются на группы, имеющие одинаковые <i>Priority</i>,  <i>Category</i>,  <i>Stack Trace</i>. Каждая группа анализируется. Первый элемент группы сразу добавляется в список уникальных рэкордов (<i>uniqLogRecordList</i>) и удаляется из группы. После этого каждый рэкорд группы сравнивается с каждым рэкордом из списка уникальных методом <i>isEqualLogRecords()</i>. Если в списке уникальных рэкордов нет рэкорда, с которым можно было бы слить данный рэкорд, он добавляется в список уникальных рэкордов и итератор переходит к следующему рэкорду группы. Если в списке уникальных рэкордов находится рэкорд, с которым можно слить данный, вызывается метод <i>join2LogRecords()</i>, который объединяет 2 рэкорда. Так перебираются все рэкорды группы. После чего рэкорды из списка <i>uniqLogRecordList</i> добавляются в результирующий список <i>uniqLogRecordListAssembled</i>. А <i>uniqLogRecordList</i> обнуляется для анализа следующей группы.</p>
    <p>В методе <i>isEqualLogRecords()</i> сравнение рэкордов происходит следующим образом: если хотя бы 1 из них не существует или они не равны по количеству токенов, то рэкорды не равны. Также не равны рэкорды, имеющие месседжи, состоятие только из 1 токена. Далее сравнивается первый токен первого рэкорда с первым токеном второго рэкорда, второй - со вторым, и т.д. Считается количество совпавших токенов. Если оно больше 75%, значит это похожие рэкорды, и их можно слить. - Метод возвращает true.</p>
    <p>Слияние двух рэкордов в методе <i>join2LogRecords()</i> происходит следующим образом: анализируются списки токенов месседжей этих рэкордов. Сравнивается первый токен первого рэкорда с первым токеном второго рэкорда, второй - со вторым, и т.д. Когда находится пара отличающихся токенов, вместо токена месседжа базового рэкорда записывается переменная в формате ${tokenNumber}. А сами токены записываются в мапу <i>mainLogRecordValuesMap</i>, в которой ключ - номер токена. Из этой мапы потом будет сформировано поле <i>MessageValues</i> в .xlsx-файле. Если в месседже базового рэкорда уже есть переменная, то токен из добавляемого рэкорда добавляется в массив <i>MessageValues</i> по ключу - номеру токена. Поля с количеством дубликатов рэкордов <i>similarRowsQuantity</i> сумируются.</p>
    <p>После окончания второго прохода рекорды сортируются по номеру строки в исходном файле и методом <i>splitListToSheets()</i> разбиваются на списки по 1_000_000 строк для того, чтобы не было переполнения листа .xlsx файла.</p>
    <p>Управление возвращается делегату, который создаёт объект генератора .xlsx файла.</p>
    <h4>Генератор .xlsx файла (<i>LogFileParserXLS.java</i>)</h4>
    <p>Делегат вызывает у генератора метод <i>generateAndSendExcelFile()</i> и передаёт ему список рэкордов, HttpServletResponse и имя .xlsx файла.</p>
    <p>Метод <i>generateAndSendExcelFile()</i> создаёт <i>SXSSFWorkbook</i> (в отличие от XSSFWorkbook использует буфер, за счёт чего может работать с большими файлами). Методом <i>generateSheet()</i> создаются листы в книге - по 1 листу на каждый 1_000_000 рэкордов. Затем методом <i>prepareResponseToSendExcelFile()</i> устанавливаются хедеры. Книга записывается в поток.</p>
    <p>В методе <i>generateSheet()</i> для полей, значения в которых могут превышать допустимое количество символов, перед записью в ячейку производиться проверка (<i>setStringValueWithCheck()</i>). Если значение превышает допустимое количество символов в ячейке, значение обрезается, а цвет текста меняется на красный.</p>
    <p>Бек логируется с помощью log4j. Лог-файл пишется в корневую папку tomcat.</p>
</body>
</html>